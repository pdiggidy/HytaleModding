---
title: "Block Ticking Systems"
description: "Learn how to create blocks that tick and execute custom logic every game tick."
authors:
    - name: "pdiggidy"
---

# Overview

In this guide, you'll learn how to create blocks with custom components that execute logic every game tick, similar to how crops grow or furnaces smelt items in Hytale.

<Callout>
For a more complete reference, you may also want to review FarmingSystems.Ticking, as much of the underlying logic is based on its implementation.
</Callout>

## Steps

### 1. TickingBlockComponent - holds block behavior

```java
public class TickingBlockComponent implements Component<ChunkStore> {

    private static final HytaleLogger LOGGER = HytaleLogger.forEnclosingClass();
    public static final BuilderCodec CODEC;

    private int tickCounter = 0;

    public TickingBlockComponent() {
    }

    public static ComponentType getComponentType() {
        return ExamplePlugin.get().getTickingBlockComponentType();
    }

    public void tick() {
        tickCounter++;

        // Only log every 5 seconds (100 ticks)
        if (tickCounter % 100 == 0) {
            LOGGER.atInfo().log("Block has been ticking for %d ticks", tickCounter);
        }

        // YOUR CUSTOM LOGIC HERE
    }

    @Nullable
    public Component<ChunkStore> clone() {
        TickingBlockComponent clone = new TickingBlockComponent();
        clone.tickCounter = this.tickCounter;
        return clone;
    }

    static {
        CODEC = BuilderCodec.builder(TickingBlockComponent.class, TickingBlockComponent::new).build();
    }
}
```

TickingBlockComponent is a custom component that stores the behavior and data for your ticking block. The `tick()` method is called every game tick (20 times per second) and contains your custom logic.

---

### 2. BlockLifecycleSystem - marks blocks as ticking when placed

```java
public class BlockLifecycleSystem extends RefSystem<ChunkStore> {

    private static final HytaleLogger LOGGER = HytaleLogger.forEnclosingClass();

    @Override
    public void onEntityAdded(@Nonnull Ref<ChunkStore> ref,
                              @Nonnull AddReason reason,
                              @Nonnull Store<ChunkStore> store,
                              @Nonnull CommandBuffer<ChunkStore> commandBuffer) {

        BlockModule.BlockStateInfo info = (BlockModule.BlockStateInfo) commandBuffer.getComponent(ref, BlockModule.BlockStateInfo.getComponentType());
        if (info == null) return;

        TickingBlockComponent tickingBlock = (TickingBlockComponent) commandBuffer.getComponent(ref, TickingBlockComponent.getComponentType());
        if (tickingBlock != null) {
            int x = ChunkUtil.xFromBlockInColumn(info.getIndex());
            int y = ChunkUtil.yFromBlockInColumn(info.getIndex());
            int z = ChunkUtil.zFromBlockInColumn(info.getIndex());

            WorldChunk worldChunk = (WorldChunk) commandBuffer.getComponent(info.getChunkRef(), WorldChunk.getComponentType());
            if (worldChunk != null) {
                worldChunk.setTicking(x, y, z, true);
                LOGGER.atInfo().log("Ticking block placed!");
            }
        }
    }

    @Override
    public void onEntityRemove(@Nonnull Ref<ChunkStore> ref,
                               @Nonnull RemoveReason reason,
                               @Nonnull Store<ChunkStore> store,
                               @Nonnull CommandBuffer<ChunkStore> commandBuffer) {
        LOGGER.atInfo().log("Ticking block removed");
    }

    @Override
    public Query getQuery() {
        return Query.and(BlockModule.BlockStateInfo.getComponentType(), TickingBlockComponent.getComponentType());
    }
}
```

BlockLifecycleSystem is a RefSystem that reacts when block entities with the TickingBlockComponent are added or removed. This is crucial for marking blocks as ticking when they're first placed.

**Key Points:**

* Tells the game that this block should tick, allowing `BlockTickingSystem` to process it.

```java
worldChunk.setTicking(x, y, z, true);
```

---

### 3. BlockTickingSystem - handles ticking

```java
public class BlockTickingSystem extends EntityTickingSystem<ChunkStore> {
    private static final Query QUERY = Query.and(BlockSection.getComponentType(), ChunkSection.getComponentType());

    @Override
    public void tick(float dt, int index, @Nonnull ArchetypeChunk<ChunkStore> archetypeChunk,
                     @Nonnull Store<ChunkStore> store, @Nonnull CommandBuffer<ChunkStore> commandBuffer) {

        BlockSection blocks = (BlockSection) archetypeChunk.getComponent(index, BlockSection.getComponentType());

        if (blocks == null || blocks.getTickingBlocksCountCopy() == 0) {
            return;
        }

        ChunkSection section = (ChunkSection) archetypeChunk.getComponent(index, ChunkSection.getComponentType());
        if (section == null) return;

        BlockComponentChunk blockComponentChunk = (BlockComponentChunk) commandBuffer.getComponent(
                section.getChunkColumnReference(),
                BlockComponentChunk.getComponentType()
        );
        if (blockComponentChunk == null) return;

        blocks.forEachTicking(blockComponentChunk, commandBuffer, section.getY(),
                (bcc, cb, localX, localY, localZ, blockId) -> {

                    Ref<ChunkStore> blockRef = bcc.getEntityReference(ChunkUtil.indexBlockInColumn(localX, localY, localZ));
                    if (blockRef == null) {
                        return BlockTickStrategy.IGNORED;
                    }

                    TickingBlockComponent tickingBlock = (TickingBlockComponent) cb.getComponent(
                            blockRef,
                            TickingBlockComponent.getComponentType()
                    );

                    if (tickingBlock != null) {
                        WorldChunk worldChunk = (WorldChunk) commandBuffer.getComponent(
                                section.getChunkColumnReference(),
                                WorldChunk.getComponentType()
                        );

                        int globalX = localX + (worldChunk.getX() * 32);
                        int globalZ = localZ + (worldChunk.getZ() * 32);

                        tickingBlock.tick();

                        return BlockTickStrategy.CONTINUE;
                    }

                    return BlockTickStrategy.IGNORED;
                }
        );
    }

    @Nullable
    public Query<ChunkStore> getQuery() {
        return QUERY;
    }
}
```

BlockTickingSystem is an EntityTickingSystem that runs every tick to execute the logic for all ticking blocks with the TickingBlockComponent.

**Key Points:**

* **Get the block component**

```java
TickingBlockComponent tickingBlock = (TickingBlockComponent) cb.getComponent(blockRef, TickingBlockComponent.getComponentType());
```

* **Convert local chunk coordinates to world coordinates**

```java
int globalX = localX + (worldChunk.getX() * 32);
int globalZ = localZ + (worldChunk.getZ() * 32);
```

* **Run the block logic**

```java
tickingBlock.tick();
```

* **Keep the block ticking in the next tick**

```java
return BlockTickStrategy.CONTINUE;
```

---

### 4. ExamplePlugin - registers components and systems

<Callout>
Systems must be registered in `start()`, not `setup()`, to ensure core component types like `BlockSection` and `ChunkSection` are available. Registering in `setup()` will cause a "query is null" error.
</Callout>

```java
public class ExamplePlugin extends JavaPlugin {
    private static ExamplePlugin instance;
    private static final HytaleLogger LOGGER = HytaleLogger.forEnclosingClass();
    private ComponentType tickingBlockComponentType;

    public static ExamplePlugin get() {
        return instance;
    }

    public ExamplePlugin(@Nonnull JavaPluginInit init) {
        super(init);
    }

    public ComponentType getTickingBlockComponentType() {
        return this.tickingBlockComponentType;
    }

    @Override
    protected void setup() {
        instance = this;

        // Register components in setup()
        this.tickingBlockComponentType = this.getChunkStoreRegistry().registerComponent(
                TickingBlockComponent.class, "TickingBlockComponent", TickingBlockComponent.CODEC
        );
    }

    @Override
    protected void start() {
        // Register systems in start() - core types are now available
        this.getChunkStoreRegistry().registerSystem(new BlockLifecycleSystem());
        this.getChunkStoreRegistry().registerSystem(new BlockTickingSystem());

        LOGGER.atInfo().log("Systems registered successfully");
    }
}
```

---

### 5. Configure In-Game

Create your block asset with the `Ticks` flag enabled and the component attached:

```json
{
  "BlockType": {
    "Flags": {
      "Ticks": true
    },
    "BlockEntity": {
      "Components": {
        "TickingBlockComponent": {}
      }
    }
  }
}
```

With this setup, your block will execute custom logic every game tick. You can modify the `tick()` method in TickingBlockComponent to implement any behavior you need.
